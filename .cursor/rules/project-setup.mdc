---
alwaysApply: true
---
# Project Goal

Spin up a **three‑package monorepo** (frontend: Flutter Web, backend: Dart Frog, shared: pure Dart models), deploy **both** to **Globe.dev**, use **Discord OAuth2** for login, persist users in **Globe DB** (SQLite-compatible), and protect APIs with **JWTs stored in HttpOnly cookies**. Roles: `user`, `captain`, `admin`. Focus is login/invite flows and a clean foundation.

---

## 0) Prerequisites

* **Flutter**: latest stable (`flutter --version`).
* **Dart Frog CLI**: `dart pub global activate dart_frog_cli`.
* **Melos** (optional but recommended for multi‑package tooling): `dart pub global activate melos`.
* **Globe CLI**: `dart pub global activate globe_cli` (or use Globe GitHub integration).
* **Node not required.**
* **Discord Developer App**: create one for OAuth2 (Client ID/Secret, redirect URLs).

> Tip: Work in **Cursor** with **Claude Sonnet 4.5** to implement each step. The monorepo layout below keeps shared code in one place.

---

## 1) Repository Layout

```
root/
  melos.yaml                # optional (recommended)
  globe.yaml                # optional config-as-code for Globe
  packages/
    shared_models/          # pure Dart: models + json_serializable
    backend/                # Dart Frog app
    frontend/               # Flutter Web app
```

**melos.yaml (optional)**

```yaml
name: bingo-globe
packages:
  - packages/**
command:
  bootstrap:
    usePubspecOverrides: true
```

Run once:

```bash
melos bootstrap
```

---

## 2) Shared Models Package (`packages/shared_models`)

Create a pure Dart package with **json_serializable** and **equatable**.

**pubspec.yaml**

```yaml
name: shared_models
version: 0.1.0
environment:
  sdk: ">=3.5.0 <4.0.0"
dependencies:
  json_annotation: ^4.9.0
  equatable: ^2.0.5
dev_dependencies:
  build_runner: ^2.4.9
  json_serializable: ^6.8.0
```

**lib/src/user.dart**

```dart
import 'package:json_annotation/json_annotation.dart';
import 'package:equatable/equatable.dart';

part 'user.g.dart';

enum UserRole { user, captain, admin }

@JsonSerializable()
class AppUser extends Equatable {
  final String id;           // internal UUID
  final String discordId;    // snowflake
  final String? globalName;  // Discord global name
  final String? username;    // Discord username
  final String? email;       // if scope allows
  final UserRole role;
  final String? teamId;      // currently assigned team for active game
  final String? gameId;      // currently joined game

  const AppUser({
    required this.id,
    required this.discordId,
    this.globalName,
    this.username,
    this.email,
    this.role = UserRole.user,
    this.teamId,
    this.gameId,
  });

  factory AppUser.fromJson(Map<String, dynamic> json) => _$AppUserFromJson(json);
  Map<String, dynamic> toJson() => _$AppUserToJson(this);

  @override
  List<Object?> get props => [id, discordId, role, teamId, gameId];
}
```

**lib/src/game_team.dart**

```dart
import 'package:json_annotation/json_annotation.dart';
import 'package:equatable/equatable.dart';

part 'game_team.g.dart';

@JsonSerializable()
class Game extends Equatable {
  final String id;          // 6-char code for captains, plus UUID internally
  final String code;        // 6 chars
  final String name;
  final DateTime createdAt;

  const Game({
    required this.id,
    required this.code,
    required this.name,
    required this.createdAt,
  });

  factory Game.fromJson(Map<String, dynamic> json) => _$GameFromJson(json);
  Map<String, dynamic> toJson() => _$GameToJson(this);

  @override
  List<Object?> get props => [id, code, name];
}

@JsonSerializable()
class Team extends Equatable {
  final String id;          // UUID
  final String gameId;
  final String name;
  final String captainUserId;

  const Team({
    required this.id,
    required this.gameId,
    required this.name,
    required this.captainUserId,
  });

  factory Team.fromJson(Map<String, dynamic> json) => _$TeamFromJson(json);
  Map<String, dynamic> toJson() => _$TeamToJson(this);

  @override
  List<Object?> get props => [id, gameId, name, captainUserId];
}
```

Generate code:

```bash
dart run build_runner build -d
```

---

## 3) Database: Globe DB (SQLite-compatible)

We’ll use **Globe DB** for persistent data and **Globe KV** for lightweight caching if needed.

**Tables (minimal viable):**

* `users(id TEXT PK, discord_id TEXT UNIQUE, global_name TEXT, username TEXT, email TEXT NULL, role TEXT NOT NULL, team_id TEXT NULL, game_id TEXT NULL)`
* `games(id TEXT PK, code TEXT UNIQUE, name TEXT, created_at TEXT)`
* `teams(id TEXT PK, game_id TEXT, name TEXT, captain_user_id TEXT)`
* `team_members(team_id TEXT, user_id TEXT, PRIMARY KEY(team_id, user_id))`
* Indexes on `discord_id`, `code`, `game_id`.

**SQL migration 001_init.sql (put in `packages/backend/migrations/001_init.sql`)**

```sql
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  discord_id TEXT NOT NULL UNIQUE,
  global_name TEXT,
  username TEXT,
  email TEXT,
  role TEXT NOT NULL DEFAULT 'user',
  team_id TEXT,
  game_id TEXT
);

CREATE TABLE IF NOT EXISTS games (
  id TEXT PRIMARY KEY,
  code TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  created_at TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS teams (
  id TEXT PRIMARY KEY,
  game_id TEXT NOT NULL,
  name TEXT NOT NULL,
  captain_user_id TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS team_members (
  team_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  PRIMARY KEY (team_id, user_id)
);

CREATE INDEX IF NOT EXISTS idx_users_discord_id ON users(discord_id);
CREATE INDEX IF NOT EXISTS idx_games_code ON games(code);
CREATE INDEX IF NOT EXISTS idx_teams_game_id ON teams(game_id);
```

> Migrations strategy: Keep raw SQL files and run them from the backend at boot if missing. (Globe DB is SQLite-compatible so simple DDL works well.)

---

## 4) Backend (`packages/backend`)

Initialize Dart Frog:

```bash
cd packages
dart_frog create backend
```

**pubspec.yaml (add libs)**

```yaml
name: backend
environment:
  sdk: ">=3.5.0 <4.0.0"
dependencies:
  dart_frog: ^1.1.0
  json_annotation: ^4.9.0
  jwt: ^3.2.2
  crypto: ^3.0.3
  uuid: ^4.5.1
  http: ^1.2.2
  shelf_cors_headers: ^0.1.5
  libsql_dart: ^0.1.8
  shared_models:
    path: ../shared_models

dev_dependencies:
  build_runner: ^2.4.9
  json_serializable: ^6.8.0
```

### 4.1 Environment variables (set locally in `.env` and on Globe dashboard)

```
DISCORD_CLIENT_ID=...
DISCORD_CLIENT_SECRET=...
DISCORD_REDIRECT_URI=https://your-api-domain/auth/discord/callback
JWT_SECRET=super-long-random-secret
GLOBE_DB_URL=libsql://...            # provided by Globe (or just DB name if Globe gives name binding)
GLOBE_DB_TOKEN=...                   # auth token
FRONTEND_ORIGIN=https://your-web-domain
COOKIE_DOMAIN=.your-domain.tld
```

### 4.2 DB bootstrap and helper

**lib/db.dart**

```dart
import 'package:libsql_dart/libsql_dart.dart' as libsql;
import 'dart:io';

class Db {
  static libsql.Client? _client;
  static libsql.Client get client => _client!;

  static Future<void> init() async {
    final url = Platform.environment['GLOBE_DB_URL'];
    final token = Platform.environment['GLOBE_DB_TOKEN'];
    if (url == null || token == null) {
      throw Exception('GLOBE_DB_URL/TOKEN missing');
    }
    _client = await libsql.createClient(url: url, authToken: token);
  }
}
```

**lib/run_migrations.dart**

```dart
import 'dart:io';
import 'package:libsql_dart/libsql_dart.dart' as libsql;
import 'db.dart';

Future<void> runMigrations() async {
  final dir = Directory('migrations');
  if (!await dir.exists()) return;
  final files = (await dir.list().toList())
      .whereType<File>()
      .where((f) => f.path.endsWith('.sql'))
      .toList()
    ..sort((a, b) => a.path.compareTo(b.path));
  for (final f in files) {
    final sql = await f.readAsString();
    await Db.client.execute(sql);
  }
}
```

Hook into `main.dart` (server entry):

```dart
import 'package:dart_frog/dart_frog.dart';
import 'lib/db.dart';
import 'lib/run_migrations.dart';

Future<HttpServer> run(Handler handler, InternetAddress ip, int port) async {
  await Db.init();
  await runMigrations();
  return serve(handler, ip, port);
}
```

### 4.3 Auth flow (Discord OAuth2 + JWT cookie)

**Middleware: `middleware.dart`**

```dart
import 'dart:io';
import 'package:dart_frog/dart_frog.dart';
import 'package:jwt/jwt.dart' as jwt;

Handler middleware(Handler handler) {
  return handler.use(requestLogger()).use(_auth());
}

Middleware _auth() {
  return (handler) {
    return (context) async {
      final cookie = context.request.cookies['auth_token'];
      if (cookie != null) {
        try {
          final secret = Platform.environment['JWT_SECRET']!;
          final decoded = jwt.verifyJwtHS256Signature(cookie.value, secret);
          context = context.provide<Object>(() => decoded.payload);
        } catch (_) {}
      }
      return handler(context);
    };
  };
}
```

**Routes**

* `routes/auth/discord/login.dart`: redirect user to Discord authorize URL with scopes (`identify`, optionally `email`).
* `routes/auth/discord/callback.dart`: exchange code for token, fetch user profile, upsert user in DB, mint JWT, set HttpOnly cookie, redirect to frontend.
* `routes/auth/logout.dart`: clear cookie.
* `routes/me/index.dart`: return current user (from JWT) and role.
* `routes/games/index.dart` (POST admin): create game & 6‑char code.
* `routes/games/[id]/teams/index.dart` (POST captain): create/join team with name.
* `routes/teams/[id]/members/index.dart` (POST add, DELETE remove) (captain‑only).
* `routes/users/index.dart` (GET list) (captain‑only for inviting).

**helpers/cookies.dart**

```dart
import 'package:dart_frog/dart_frog.dart';
import 'dart:io';

Response setAuthCookie(Response res, String jwtToken) {
  final domain = Platform.environment['COOKIE_DOMAIN'];
  return res.copyWith(headers: {
    ...res.headers,
    'set-cookie': Cookie('auth_token', jwtToken)
      ..httpOnly = true
      ..secure = true
      ..sameSite = SameSite.lax
      ..path = '/'
      ..domain = domain
      ..maxAge = const Duration(days: 30)
      .toString(),
  });
}
```

**helpers/jwt.dart**

```dart
import 'dart:io';
import 'package:jwt/jwt.dart' as jwt;

String signJwt(Map<String, Object?> payload) {
  final secret = Platform.environment['JWT_SECRET']!;
  final token = jwt.JwtHS256Codec(secret).encode({
    ...payload,
    'iat': DateTime.now().millisecondsSinceEpoch ~/ 1000,
    'exp': DateTime.now().add(const Duration(days: 30)).millisecondsSinceEpoch ~/ 1000,
  });
  return token;
}
```

> All protected routes check the decoded JWT in context. Add small role guards per route.

**CORS**: allow `FRONTEND_ORIGIN`, send credentials; but since we use cookies and same site, prefer same domain/subdomain to avoid CORS where possible.

---

## 5) Frontend (`packages/frontend`)

Create Flutter app:

```bash
cd packages
flutter create frontend
```

**pubspec.yaml**

```yaml
name: frontend
environment:
  sdk: ">=3.5.0 <4.0.0"
dependencies:
  flutter:
    sdk: flutter
  flutter_bloc: ^9.0.0
  equatable: ^2.0.5
  get_it: ^7.7.0
  dio: ^5.7.0
  go_router: ^14.2.0
  shared_models:
    path: ../shared_models

dev_dependencies:
  flutter_test:
    sdk: flutter
```

### 5.1 Theming (Material 3, dark)

**lib/theme/app_theme.dart**

```dart
import 'package:flutter/material.dart';

ThemeData buildDarkTheme() {
  return ThemeData(
    useMaterial3: true,
    brightness: Brightness.dark,
    colorSchemeSeed: const Color(0xFF80CBC4),
    visualDensity: VisualDensity.standard,
    inputDecorationTheme: const InputDecorationTheme(
      border: OutlineInputBorder(),
    ),
  );
}
```

### 5.2 DI + HTTP

**lib/di.dart**

```dart
import 'package:get_it/get_it.dart';
import 'package:dio/dio.dart';

final sl = GetIt.instance;

void setupDi() {
  final dio = Dio(BaseOptions(
    baseUrl: const String.fromEnvironment('API_BASE', defaultValue: '/'),
    // With cookies, browser manages them automatically
    validateStatus: (code) => code != null && code < 500,
  ));
  sl.registerSingleton<Dio>(dio);
}
```

### 5.3 Auth BLoC (cookie-based)

* On app start, call `/me` to fetch current user. If `401`, show Login page.
* Login button hits backend `/auth/discord/login` (which redirects to Discord then back to frontend). After redirect, `/me` should succeed and you can route to `/lobby`.

**lib/auth/auth_bloc.dart** (sketch)

```dart
import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:dio/dio.dart';
import 'package:shared_models/shared_models.dart';

part 'auth_state.dart';

enum AuthStatus { unknown, unauthenticated, authenticated }

class AuthBloc extends Cubit<AuthState> {
  final Dio _dio;
  AuthBloc(this._dio) : super(const AuthState.unknown());

  Future<void> check() async {
    final res = await _dio.get('/me');
    if (res.statusCode == 200) {
      emit(AuthState.authenticated(AppUser.fromJson(res.data)));
    } else {
      emit(const AuthState.unauthenticated());
    }
  }

  Uri discordLoginUri() => Uri.parse('/auth/discord/login');
  Future<void> logout() async { await _dio.post('/auth/logout'); emit(const AuthState.unauthenticated()); }
}
```

**lib/auth/auth_state.dart**

```dart
part of 'auth_bloc.dart';

class AuthState extends Equatable {
  final AuthStatus status; final AppUser? user;
  const AuthState._(this.status, this.user);
  const AuthState.unknown() : this._(AuthStatus.unknown, null);
  const AuthState.unauthenticated() : this._(AuthStatus.unauthenticated, null);
  const AuthState.authenticated(AppUser u) : this._(AuthStatus.authenticated, u);
  @override List<Object?> get props => [status, user];
}
```

### 5.4 Navigation (GoRouter)

**lib/router.dart**

```dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'auth/auth_bloc.dart';
import 'screens/screens.dart';

GoRouter buildRouter(AuthBloc auth) {
  return GoRouter(
    initialLocation: '/lobby',
    refreshListenable: GoRouterRefreshStream(auth.stream),
    redirect: (context, state) {
      final status = auth.state.status;
      final loggingIn = state.subloc == '/login';
      if (status == AuthStatus.unknown) return null; // keep
      if (status == AuthStatus.unauthenticated && !loggingIn) return '/login';
      if (status == AuthStatus.authenticated && loggingIn) return '/lobby';
      return null;
    },
    routes: [
      GoRoute(path: '/login', builder: (_, __) => const LoginScreen()),
      GoRoute(path: '/lobby', builder: (_, __) => const LobbyScreen()),
      GoRoute(path: '/game/:id', builder: (_, s) => GameScreen(id: s.pathParameters['id']!)),
      GoRoute(path: '/profile', builder: (_, __) => const ProfileScreen()),
      GoRoute(path: '/admin', builder: (_, __) => const AdminScreen()),
    ],
  );
}
```

### 5.5 Screens (lobby variants)

**lib/screens/lobby_screen.dart** (sketch)

```dart
class LobbyScreen extends StatelessWidget {
  const LobbyScreen({super.key});
  @override
  Widget build(BuildContext context) {
    final auth = context.select((AuthBloc b) => b.state);
    final user = auth.user;
    if (user == null) return const SizedBox.shrink();

    Widget normalUser() => const Center(
      child: Text('Ask your captain for an invite. Please wait.'),
    );

    Widget captain() => Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('Captain Tools', style: Theme.of(context).textTheme.headlineSmall),
          const SizedBox(height: 16),
          TextField(decoration: const InputDecoration(labelText: 'Game code (6 chars)')),
          const SizedBox(height: 12),
          TextField(decoration: const InputDecoration(labelText: 'Team name')),
          const SizedBox(height: 12),
          FilledButton(onPressed: () {/* join/create team call */}, child: const Text('Join Game')),
        ],
      ),
    );

    Widget admin() => Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('Admin Tools', style: Theme.of(context).textTheme.headlineSmall),
          const SizedBox(height: 16),
          TextField(decoration: const InputDecoration(labelText: 'Create game name')),
          const SizedBox(height: 12),
          FilledButton(onPressed: () {/* create game */}, child: const Text('Create Game')),
          const Divider(height: 32),
          captain(),
        ],
      ),
    );

    switch (user.role) {
      case UserRole.admin: return admin();
      case UserRole.captain: return captain();
      case UserRole.user: default: return normalUser();
    }
  }
}
```

**Profile screen**: show user info, team mates, captain, and a **Logout** button calling `/auth/logout` then route to `/login`.

**Admin screen**: list `games` with a delete button (simple table, call backend DELETE `/games/:id`).

**Captain management**: a page with two lists (all users with `Invite` button; current team members with `Remove`). Calls backend accordingly.

---

## 6) Auth Flow Details (Discord → JWT cookie)

1. Frontend clicks **Login with Discord** → request `/auth/discord/login`.
2. Backend redirects to Discord authorize with scopes: `identify` (optional `email`).
3. Discord redirects back to `/auth/discord/callback?code=...`.
4. Backend exchanges code → gets access token → fetches user profile.
5. **Upsert** in DB by `discord_id`. Only persist useful fields: `discord_id`, `global_name`, `username`, `email?`, `role`.
6. Backend issues **JWT** (`sub=internal user id`, plus role) and sets **HttpOnly, Secure, SameSite=Lax** cookie for 30 days.
7. Frontend calls `/me` to load user context; router shows lobby/profile/admin accordingly.

> Note: Keep access tokens out of the frontend—only store our session JWT in a cookie.

---

## 7) Role/Guarding Strategy

* Add small helpers per route:

  * `requireAuth(context)` → returns userId from JWT or `401`.
  * `requireRole(context, role)` → `403` if not allowed.
* Captain-only endpoints: team management & invites.
* Admin-only endpoints: create/delete games, elevate users to captain if needed.

---

## 8) Local Development

**Backend**:

```bash
cd packages/backend
cp .env.example .env    # fill in variables
dart_frog dev
```

**Frontend**:

```bash
cd packages/frontend
flutter run -d chrome
```

Set redirect URIs to `http://localhost:8080/auth/discord/callback` (or whatever port Dart Frog uses). Point `API_BASE` to the backend origin if not same host.

---

## 9) Deployment on Globe.dev

Two approaches: **Globe CLI** or **GitHub integration**.

### 9.1 Backend (Dart Frog)

* From `packages/backend`, run `globe deploy` or connect repo in the Globe dashboard and set project root.
* Set env vars on Globe: `DISCORD_*`, `JWT_SECRET`, `GLOBE_DB_URL`, `GLOBE_DB_TOKEN`, `FRONTEND_ORIGIN`, `COOKIE_DOMAIN`.
* Add a custom domain (optional) for the API, e.g. `api.your-domain.tld`.

### 9.2 Frontend (Flutter Web)

* From `packages/frontend`, `flutter build web` (Globe will do this automatically if configured).
* Deploy via Globe Flutter Web preset. Attach domain like `app.your-domain.tld`.

### 9.3 Globe DB

* Create a **Globe DB** instance in the Globe dashboard.
* Copy the `URL` and `TOKEN` into backend env vars.
* First boot runs migrations automatically.

### 9.4 Domains & Cookies

* Prefer subdomains under the same apex, e.g. `app.example.com` and `api.example.com`.
* Set `COOKIE_DOMAIN=.example.com` so the cookie is valid for both.

---

## 10) Minimal Backend Route Sketches

**routes/auth/discord/login.dart**

```dart
import 'package:dart_frog/dart_frog.dart';
import 'dart:io';

Response onRequest(RequestContext context) {
  final id = Platform.environment['DISCORD_CLIENT_ID']!;
  final redirect = Uri.parse(Platform.environment['DISCORD_REDIRECT_URI']!);
  final authUrl = Uri.https('discord.com', '/api/oauth2/authorize', {
    'client_id': id,
    'response_type': 'code',
    'scope': 'identify email',
    'redirect_uri': redirect.toString(),
    'prompt': 'consent'
  });
  return Response.permanentRedirect(authUrl.toString());
}
```

**routes/auth/discord/callback.dart** (outline)

```dart
// 1) Exchange code for token
// 2) Fetch user profile
// 3) Upsert into DB
// 4) Sign JWT & set cookie
// 5) Redirect to FRONTEND_ORIGIN
```

**routes/me/index.dart** (simple)

```dart
import 'package:dart_frog/dart_frog.dart';

Response onRequest(RequestContext context) {
  final payload = context.read<Object?>();
  if (payload == null) return Response(statusCode: 401);
  // Load user from DB by payload['sub'] and return JSON
  return Response.json(body: {/* user json */});
}
```

---

## 11) Captain Team Management (API surface)

* `GET /users` → list all users (for invite list) *(admin/captain)*
* `POST /games` `{ name }` → create game, returns `{ id, code }` *(admin)*
* `POST /games/{id}/teams` `{ name }` → create team for captain *(captain)*
* `POST /teams/{id}/members` `{ userId }` → invite/add *(captain)*
* `DELETE /teams/{id}/members/{userId}` → remove *(captain)*
* `GET /games/{id}` → summary (teams, members)

> Everyone can be part of **one game at a time**. Enforce with `users.game_id`.

---

## 12) Frontend UI Notes

* **Material 3** dark theme, keep surfaces padded, use cards for lists.
* Extract widgets to `/lib/widgets/*` (inputs, filled buttons, tables).
* Use responsive `LayoutBuilder` for two‑column captain page.
* Keep BLoCs small: `AuthBloc`, `LobbyBloc`, `TeamBloc`.

---

## 13) Security Checklist

* JWT in **HttpOnly + Secure + SameSite=Lax** cookie (30‑day expiry).
* Set CORS to only allow your frontend origin if needed.
* Never expose Discord access tokens to the client.
* Rate limit sensitive endpoints (simple in‑memory or Globe KV).

---

## 14) Next Steps (after base is running)

* Add **game logic** and board state.
* Add **invitation notifications** via Discord bot webhooks (optional).
* Build **admin dashboards** for audits.
* Add **role elevation** endpoint to set captains.
* Add **pagination** to users list.
* Add **e2e tests** with `flutter_test` + `integration_test` and lightweight API tests.

---

## 15) Commands Cheat‑Sheet

```bash
# bootstrap workspace
melos bootstrap

# shared models
dart run build_runner build -d

# backend
dart_frog dev

# frontend
flutter run -d chrome

# deploy (per package)
cd packages/backend && globe deploy
cd packages/frontend && globe deploy
```

---

## 16) Implementation Order (commit‑by‑commit useful for Cursor)

1. **chore(repo):** init monorepo structure + melos.yaml
2. **feat(shared):** add shared_models (AppUser, Game, Team) + json_serializable
3. **feat(backend):** init Dart Frog, add DB client + migrations runner
4. **feat(db):** add 001_init.sql tables
5. **feat(auth):** Discord login & callback routes, JWT cookie helpers, `/me`
6. **feat(frontend):** init Flutter, theme, DI, AuthBloc, router, login screen
7. **feat(lobby):** lobby variants (user/captain/admin) + stubs for actions
8. **feat(teams):** captain team management UI + API endpoints
9. **feat(admin):** create/delete games UI + endpoints
10. **chore(deploy):** add globe configs, set env vars, first deploy

---

## 17) What to Persist from Discord

* `discord_id` (snowflake) — **required**
* `global_name`, `username` — for display
* `email` — only if you request `email` scope (optional)
* **Never store** tokens/refresh tokens in plaintext; we don’t need them after identity confirmation.

---

## 18) Globe Tips

* Use **globe.yaml** at the repo root to define build commands per package (frontend/backend) if you want single‑repo deployments.
* Prefer same apex domain for cookie sharing (`.example.com`).
* Globe DB is great for this scale; for hot paths, consider **Globe KV** cache.

---

## 19) GitHub Actions Deployment (CI/CD)

Deploy automatically on every merge to `main` using GitHub Actions workflows.

### 19.1 Workflow Strategy

* **Path-based triggers**: Deploy backend only when `packages/backend/**` changes; frontend only when `packages/frontend/**` changes.
* **Shared models**: If `packages/shared_models/**` changes, deploy both frontend and backend.
* **Use Globe CLI** in actions to trigger deployments.
* **Secrets**: Store `GLOBE_TOKEN` and environment variables as GitHub repository secrets.

### 19.2 Backend Deployment Workflow

**.github/workflows/deploy-backend.yml**

```yaml
name: Deploy Backend

on:
  push:
    branches:
      - main
    paths:
      - 'packages/backend/**'
      - 'packages/shared_models/**'
      - '.github/workflows/deploy-backend.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - uses: dart-lang/setup-dart@v1
        with:
          sdk: stable
      
      - name: Install Melos
        run: dart pub global activate melos
      
      - name: Bootstrap packages
        run: melos bootstrap
      
      - name: Install Globe CLI
        run: dart pub global activate globe_cli
      
      - name: Deploy to Globe
        working-directory: packages/backend
        env:
          GLOBE_TOKEN: ${{ secrets.GLOBE_TOKEN }}
        run: globe deploy --token $GLOBE_TOKEN
      
      - name: Set environment variables
        if: success()
        run: |
          globe env set DISCORD_CLIENT_ID="${{ secrets.DISCORD_CLIENT_ID }}" --token ${{ secrets.GLOBE_TOKEN }}
          globe env set DISCORD_CLIENT_SECRET="${{ secrets.DISCORD_CLIENT_SECRET }}" --token ${{ secrets.GLOBE_TOKEN }}
          globe env set DISCORD_REDIRECT_URI="${{ secrets.DISCORD_REDIRECT_URI }}" --token ${{ secrets.GLOBE_TOKEN }}
          globe env set JWT_SECRET="${{ secrets.JWT_SECRET }}" --token ${{ secrets.GLOBE_TOKEN }}
          globe env set GLOBE_DB_URL="${{ secrets.GLOBE_DB_URL }}" --token ${{ secrets.GLOBE_TOKEN }}
          globe env set GLOBE_DB_TOKEN="${{ secrets.GLOBE_DB_TOKEN }}" --token ${{ secrets.GLOBE_TOKEN }}
          globe env set FRONTEND_ORIGIN="${{ secrets.FRONTEND_ORIGIN }}" --token ${{ secrets.GLOBE_TOKEN }}
          globe env set COOKIE_DOMAIN="${{ secrets.COOKIE_DOMAIN }}" --token ${{ secrets.GLOBE_TOKEN }}
```

### 19.3 Frontend Deployment Workflow

**.github/workflows/deploy-frontend.yml**

```yaml
name: Deploy Frontend

on:
  push:
    branches:
      - main
    paths:
      - 'packages/frontend/**'
      - 'packages/shared_models/**'
      - '.github/workflows/deploy-frontend.yml'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - uses: subosito/flutter-action@v2
        with:
          flutter-version: 'stable'
          channel: 'stable'
      
      - uses: dart-lang/setup-dart@v1
        with:
          sdk: stable
      
      - name: Install Melos
        run: dart pub global activate melos
      
      - name: Bootstrap packages
        run: melos bootstrap
      
      - name: Build Flutter Web
        working-directory: packages/frontend
        run: flutter build web --release --dart-define=API_BASE=${{ secrets.API_BASE_URL }}
      
      - name: Install Globe CLI
        run: dart pub global activate globe_cli
      
      - name: Deploy to Globe
        working-directory: packages/frontend
        env:
          GLOBE_TOKEN: ${{ secrets.GLOBE_TOKEN }}
        run: globe deploy --token $GLOBE_TOKEN
```

### 19.4 Combined Workflow (Optional)

If you prefer a single workflow that intelligently deploys based on changes:

**.github/workflows/deploy.yml**

```yaml
name: Deploy to Globe

on:
  push:
    branches:
      - main

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            backend:
              - 'packages/backend/**'
              - 'packages/shared_models/**'
            frontend:
              - 'packages/frontend/**'
              - 'packages/shared_models/**'

  deploy-backend:
    needs: detect-changes
    if: needs.detect-changes.outputs.backend == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dart-lang/setup-dart@v1
      - run: dart pub global activate melos
      - run: melos bootstrap
      - run: dart pub global activate globe_cli
      - working-directory: packages/backend
        env:
          GLOBE_TOKEN: ${{ secrets.GLOBE_TOKEN }}
        run: globe deploy --token $GLOBE_TOKEN

  deploy-frontend:
    needs: detect-changes
    if: needs.detect-changes.outputs.frontend == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: subosito/flutter-action@v2
      - uses: dart-lang/setup-dart@v1
      - run: dart pub global activate melos
      - run: melos bootstrap
      - working-directory: packages/frontend
        run: flutter build web --release
      - run: dart pub global activate globe_cli
      - working-directory: packages/frontend
        env:
          GLOBE_TOKEN: ${{ secrets.GLOBE_TOKEN }}
        run: globe deploy --token $GLOBE_TOKEN
```

### 19.5 Required GitHub Secrets

Add these secrets in your GitHub repository settings (`Settings → Secrets and variables → Actions`):

**Globe & Deployment:**
- `GLOBE_TOKEN` - Your Globe.dev API token

**Backend Environment:**
- `DISCORD_CLIENT_ID`
- `DISCORD_CLIENT_SECRET`
- `DISCORD_REDIRECT_URI` (e.g., `https://api.yourdomain.com/auth/discord/callback`)
- `JWT_SECRET` (generate with `openssl rand -base64 32`)
- `GLOBE_DB_URL` (from Globe dashboard)
- `GLOBE_DB_TOKEN` (from Globe dashboard)
- `FRONTEND_ORIGIN` (e.g., `https://app.yourdomain.com`)
- `COOKIE_DOMAIN` (e.g., `.yourdomain.com`)

**Frontend Environment:**
- `API_BASE_URL` (e.g., `https://api.yourdomain.com`)

### 19.6 Alternative: Globe GitHub Integration

Instead of using Globe CLI in actions, you can use **Globe's native GitHub integration**:

1. Connect your GitHub repo in the Globe dashboard
2. Create two Globe projects:
   - **Backend project**: Set root directory to `packages/backend`
   - **Frontend project**: Set root directory to `packages/frontend`, type: Flutter Web
3. Enable auto-deploy on push to `main`
4. Set environment variables in Globe dashboard (not GitHub secrets)

This approach is simpler but gives less control over when/how deployments happen.

### 19.7 Testing Deployments

To test workflows without deploying, add a workflow that runs on PRs:

**.github/workflows/test.yml**

```yaml
name: Test Build

on:
  pull_request:
    branches:
      - main

jobs:
  test-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dart-lang/setup-dart@v1
      - run: dart pub global activate melos
      - run: melos bootstrap
      - working-directory: packages/backend
        run: dart test

  test-frontend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: subosito/flutter-action@v2
      - uses: dart-lang/setup-dart@v1
      - run: melos bootstrap
      - working-directory: packages/frontend
        run: flutter test
```

### 19.8 Deployment Checklist

Before setting up GitHub Actions:

1. ✅ Create Globe account and projects
2. ✅ Set up Globe DB instance
3. ✅ Generate `GLOBE_TOKEN` from Globe dashboard
4. ✅ Generate secure `JWT_SECRET` (`openssl rand -base64 32`)
5. ✅ Create Discord OAuth2 application
6. ✅ Set up custom domains (optional but recommended)
7. ✅ Add all secrets to GitHub repository
8. ✅ Test manual deployment first (`globe deploy` locally)
9. ✅ Commit and push workflows to `main`

---

### Done

This gets you to a working base: login via Discord, user persisted, JWT cookie session, role‑based lobby, captain/admin tools, deployable frontend+backend on Globe.dev with automated CI/CD via GitHub Actions.
