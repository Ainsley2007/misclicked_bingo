---
alwaysApply: true
---
# Bloc Rules (GetIt + sealed classes)

> This version replaces `Provider`-style DI with **GetIt** and prefers **Dart sealed classes** over `Equatable` for events and states.

---

## Naming Conventions

1. Name events in the past tense, as they represent actions that have already occurred from the bloc's perspective.
2. Use the format: `BlocSubject` + optional noun + verb (event). Example: `LoginButtonPressed`, `UserProfileLoaded`
3. For initial load events, use: `BlocSubjectStarted`. Example: `AuthenticationStarted`
4. The base event class should be named: `BlocSubjectEvent` and declared as `sealed`.
5. Name states as nouns, since a state is a snapshot at a particular point in time.
6. When using subclasses for states, use the format: `BlocSubject` + `Initial` | `Success` | `Failure` | `InProgress`. Example: `LoginInitial`, `LoginSuccess`, `LoginFailure`, `LoginInProgress`
7. For single-class states, use: `BlocSubjectState` with a `BlocSubjectStatus` enum (`initial`, `success`, `failure`, `loading`). Example: `LoginState` with `LoginStatus.initial`
8. The base state class should always be named: `BlocSubjectState` and declared as `sealed`.

---

## Modeling State

1. Prefer sealed classes for events and states to ensure exhaustive handling and mutual exclusivity.
2. Annotate state classes with `@immutable` to enforce immutability.
3. Use `const` constructors for state classes when possible.
4. For shared properties, place them on the sealed base class; keep specific ones in subclasses.
5. Add `==` and `hashCode` overrides where equality is important, or use `freezed` for generated equality and `copyWith`.
6. Use exhaustive `switch` statements for type-safe state handling.
7. Use a single-class state with a status enum when many fields are shared or to retain data after an error.
8. Emit new state instances on every update.

---

## Bloc Concepts

1. Use `Cubit` for simple state management; `Bloc` for event-driven logic.
2. Define the initial state in the super constructor.
3. Only call `emit` inside a `Cubit` or `Bloc`.
4. UI components should listen to state changes and update accordingly.
5. Duplicate states are ignored if equal.
6. Use `onChange` for local logging; use a global `BlocObserver` for app-wide logging.
7. Override `onError` in both cubit/bloc and the observer.
8. Add events to blocs based on UI or lifecycle triggers.
9. For cubits, public methods should return `void` or `Future<void>`.
10. Use `onTransition` for detailed state transition logging.
11. Use transformers like debounce or throttle when needed.
12. Start with cubit if unsure; refactor to bloc later.
13. Initialize `BlocObserver` in `main.dart`.
14. Keep business logic out of widgets.
15. Internal events should be private.
16. Call `BlocProvider.of(context)` in a child context.

---

## Architecture

1. Separate features into Presentation, Business Logic, and Data layers.
2. The Data Layer contains repositories and data providers.
3. The Business Logic Layer handles input from UI and talks to repositories.
4. The Presentation Layer renders UI and manages lifecycle events.
5. Inject repositories into blocs via constructors.
6. Avoid direct bloc-to-bloc communication.
7. Coordinate blocs using `BlocListener` in the UI.
8. Inject shared repositories into multiple blocs when needed.
9. Keep architecture loosely coupled and consistent.

---

## Dependency Injection with GetIt

1. Use GetIt instead of Provider for dependency injection.
2. Register dependencies in a setup method and resolve at the composition root.
3. Use `registerFactory` for blocs so they remain short-lived.
4. Use scopes for feature-level dependencies and clean up with `popScope()`.
5. Avoid calling `GetIt.I<T>()` inside blocs or repositories; prefer constructor injection.
6. Do not mix GetIt with RepositoryProvider.

---

## Flutter Bloc Concepts

1. Use `BlocBuilder` to rebuild widgets in response to bloc or cubit state changes.
2. Use `BlocListener` for side effects like navigation or showing dialogs.
3. Use `BlocConsumer` when both building and listening are required.
4. Provide blocs using `BlocProvider(create: (_) => getIt<MyBloc>())`.
5. Use `MultiBlocProvider` to provide multiple blocs.
6. Use `BlocSelector` to rebuild only when a selected part of the state changes â€” this improves performance by limiting unnecessary rebuilds.
7. Use `context.read<T>()` for one-time access without rebuilds.
8. Prefer `BlocBuilder` and `BlocSelector` for controlled rebuilds.
9. Scope rebuilds properly and handle all state cases explicitly.

---

## Code Quality & Linting

1. Use `bloc_lint` for enforcing best practices.
2. Avoid Flutter imports in business logic.
3. Avoid public fields in blocs or cubits.
4. Avoid public bloc methods; use events.
5. Prefer cubit where simpler.
6. Configure analysis options properly.
7. Optionally use `freezed` for sealed unions and `copyWith`.

---

## Testing

1. Use `test` and `bloc_test` for bloc testing.
2. Organize tests into groups and use setup/teardown.
3. Test initial state and transitions.
4. Use `blocTest` for event-to-state assertions.
5. Use GetIt scopes to isolate dependencies in tests.
6. Mock blocs in widget tests.

---